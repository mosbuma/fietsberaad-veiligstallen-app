import type { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "~/server/db";
import { getServerSession } from "next-auth";
import { authOptions } from '~/pages/api/auth/[...nextauth]'
import { z } from "zod";
import { validateUserSession } from "~/utils/server/database-tools";
import { VSUserRoleValuesNew } from "~/types/users";
import { generateID } from "~/utils/server/database-tools";

export type VSExploitantGemeenteLink = {
  ID: number;
  parentSiteID: string;
  childSiteID: string;
  admin: boolean;
}

export type ExploitantGemeenteResponse = {
  data?: VSExploitantGemeenteLink;
  error?: string;
};

const adminSchema = z.object({
  admin: z.boolean()
});

const updateExploitantUsersForContact = async (expoitantid: string, contactid: string, unlink: boolean) => {
  const exploitantname = (await prisma.contacts.findUnique({  
    select: {
      CompanyName: true
    },
    where: {
      ID: expoitantid
    }
  }))?.CompanyName || "unknown";

  const contactname = (await prisma.contacts.findUnique({  
    select: {
      CompanyName: true
    },
    where: {
      ID: contactid
    }
  }))?.CompanyName || "unknown";
  
  console.log(`updateExploitantUsersForContact - expoitant: ${exploitantname} contact: ${contactname} unlink: ${unlink}`);

  // first get all users of the exploitant
  const exploitantUsers = await prisma.user_contact_role.findMany({
    where: {
      ContactID: expoitantid,
      isOwnOrganization: true
    },
    select: {
      UserID: true,
      NewRoleID: true
    }
  });

  for (const user of exploitantUsers) {
    if(unlink) {
      // then delete all of these users for the given contactid
      console.log(`delete exploitant ${exploitantname} user ${user.UserID} from gemeente ${contactname}/${contactid}`);
      await prisma.user_contact_role.deleteMany({
        where: {
          ContactID: contactid,
          UserID: user.UserID
        }
      });
    } else {
      // get count of existing entries in user_contact_role for user  
      const count = await prisma.user_contact_role.count({
        where: {
          UserID: user.UserID,
          ContactID: contactid
        }
      });
      console.log(`** user ${user.UserID} has ${count} entries in user_contact_role`);

      const newrole = user.NewRoleID === VSUserRoleValuesNew.RootAdmin ? VSUserRoleValuesNew.Admin : VSUserRoleValuesNew.None;
      console.log(`add exploitant ${exploitantname}/${expoitantid} user ${user.UserID} to gemeente ${contactname}/${contactid} as ${newrole}`);
      await prisma.user_contact_role.create({
        data: {
          ID: generateID(),
          ContactID: contactid,
          UserID: user.UserID,
          NewRoleID: newrole
        }
      });
    }
  }
}

export default async function handle(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getServerSession(req, res, authOptions);
  if (!session?.user) {
    console.error("Unauthorized - no session found");
    res.status(401).json({error: "Unauthorized - no session found"}); // Unauthorized
    return;
  }

  const validateUserSessionResult = await validateUserSession(session, "exploitant");
  if ('error' in validateUserSessionResult) {
    console.error("Unauthorized - invalid session", validateUserSessionResult.error);
    res.status(validateUserSessionResult.status).json({error: `validate user session error:${validateUserSessionResult.status} - ${validateUserSessionResult.error}`});
    return;
  }

  const { sites } = validateUserSessionResult;

  const id = req.query.id as string;
  const gemeenteid = req.query.gemeenteid as string;
  if (!sites.includes(id)) {
    console.error("Unauthorized - no access to this organization", id);
    res.status(403).json({ error: "Geen toegang tot deze organisatie" });
    return;
  }

  switch (req.method) {
    case "GET": {
      try {
        const link = await prisma.contact_contact.findFirst({
          where: {
            parentSiteID: id,
            childSiteID: gemeenteid
          },
          select: {
            ID: true,
            parentSiteID: true,
            childSiteID: true,
            admin: true
          }
        });

        if (!link) {
          res.status(404).json({ error: "Koppeling niet gevonden" });
          return;
        }

        res.status(200).json({ data: link });
      } catch (e) {
        console.error("Fout bij het ophalen van koppeling:", e);
        res.status(500).json({ error: "Fout bij het ophalen van koppeling" });
      }
      break;
    }
    case "POST": {
      try {
        const admin = req.body.admin ?? true;
        
        const newLink = await prisma.contact_contact.create({
          data: {
            parentSiteID: id,
            childSiteID: gemeenteid,
            admin: admin
          }
        });

        await updateExploitantUsersForContact(id, gemeenteid, false);        

        // TODO: fill in coldfusion style relation too if possible

        res.status(201).json({ data: newLink });
      } catch (e) {
        console.error("Fout bij het aanmaken van koppeling:", e);
        res.status(500).json({ error: "Fout bij het aanmaken van koppeling" });
      }
      break;
    }
    case "PUT": {
      try {
        const parseResult = adminSchema.safeParse(req.body);
        if (!parseResult.success) {
          console.error("Ongeldige admin waarde:", parseResult.error);
          res.status(400).json({ error: "Ongeldige admin waarde" });
          return;
        }

        const { admin } = parseResult.data;
        
        const updatedLink = await prisma.contact_contact.update({
          where: {
            parentSiteID_childSiteID: {
              parentSiteID: id,
              childSiteID: gemeenteid
            }
          },
          data: {
            admin: admin
          }
        });

        await updateExploitantUsersForContact(id, gemeenteid, false);        

        res.status(200).json({ data: updatedLink });
      } catch (e) {
        if (e instanceof z.ZodError) {
          console.error("Ongeldige gegevens:", e.errors);
          res.status(400).json({ error: e.errors });
        } else {
          console.error("Fout bij het bijwerken van koppeling:", e);
          res.status(500).json({ error: "Fout bij het bijwerken van koppeling" });
        }
      }
      break;
    }
    case "DELETE": {
      console.debug(`POST request - UNLINK ${id} from gemeente ${gemeenteid}`);
      try {

        await updateExploitantUsersForContact(id, gemeenteid, true);        

        await prisma.contact_contact.delete({
          where: {
            parentSiteID_childSiteID: {
              parentSiteID: id,
              childSiteID: gemeenteid
            }
          }
        });

        res.status(200).json({ data: null });
      } catch (e) {
        console.error("Fout bij het verwijderen van koppeling:", e);
        res.status(500).json({ error: "Fout bij het verwijderen van koppeling" });
      }
      break;
    }
    default: {
      res.status(405).json({ error: "Methode niet toegestaan" }); // Method Not Allowed
    }
  }
} 